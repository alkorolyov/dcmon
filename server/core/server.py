#!/usr/bin/env python3
"""
dcmon Server Factory - FastAPI App Creation and Lifecycle Management
"""

import asyncio
import logging
from contextlib import asynccontextmanager
from pathlib import Path
from typing import Optional

from fastapi import FastAPI

# Support running as script or as package
try:
    from ..models import db_manager, MetricPointsInt, MetricPointsFloat
    from ..api.dependencies import AuthDependencies
    from ..api.routes.auth_routes import create_auth_routes
    from ..api.routes.admin_routes import create_admin_routes
    from ..api.routes.command_routes import create_command_routes
    from ..api.routes.metrics_routes import create_metrics_routes
    from ..api.routes.dashboard_routes import create_dashboard_routes
    from .config import ServerConfig, resolve_paths, read_admin_token
except ImportError:
    from models import db_manager, MetricPointsInt, MetricPointsFloat
    from api.dependencies import AuthDependencies
    from api.routes.auth_routes import create_auth_routes
    from api.routes.admin_routes import create_admin_routes
    from api.routes.command_routes import create_command_routes
    from api.routes.metrics_routes import create_metrics_routes
    from api.routes.dashboard_routes import create_dashboard_routes
    from core.config import ServerConfig, resolve_paths, read_admin_token

logger = logging.getLogger("dcmon.server")


def setup_logging(config: ServerConfig):
    """Configure logging early in startup process including audit logging."""
    log_level = getattr(logging, config.log_level.upper(), logging.INFO)
    logging.basicConfig(level=log_level, format='%(levelname)s:%(name)s:%(message)s')
    logging.getLogger().setLevel(log_level)
    logger.setLevel(log_level)
    
    # Configure audit logging with separate file handler
    audit_logger = logging.getLogger("dcmon.audit")
    audit_logger.setLevel(logging.INFO)
    
    try:
        from logging.handlers import RotatingFileHandler
        audit_handler = RotatingFileHandler(
            "audit.log", 
            maxBytes=10*1024*1024,  # 10MB
            backupCount=5
        )
        audit_formatter = logging.Formatter('%(message)s')  # JSON format, no extra formatting
        audit_handler.setFormatter(audit_formatter)
        audit_logger.addHandler(audit_handler)
        
        # Prevent audit logs from going to console
        audit_logger.propagate = False
        logger.info("Audit logging configured: audit.log")
    except Exception as e:
        logger.warning(f"Failed to setup audit logging: {e}")
    
    # Silence noisy third-party loggers
    logging.getLogger('peewee').setLevel(logging.WARNING)


def create_app(config: ServerConfig) -> FastAPI:
    """
    Build the FastAPI app using the provided config.
    Clean separation: Configuration (read once) vs Runtime Resources (lifespan managed).
    """
    # 1. CONFIGURATION PHASE (immutable, read once at startup)
    db_path, admin_token_path, allow_ephemeral, cert_path, key_path = resolve_paths(config)
    admin_token = read_admin_token(admin_token_path)
    
    # Admin token validation
    if admin_token is None and allow_ephemeral:
        admin_token = "dev_admin_token_12345"
        logger.warning("Using dev admin token: %s (create %s for custom token)", admin_token, admin_token_path)
    elif admin_token is None:
        raise RuntimeError(
            f"Admin token file missing at {admin_token_path}. "
            f"Create it with a secure token generated by the installer."
        )
    
    # 2. Create authentication dependencies immediately
    auth_deps = AuthDependencies(admin_token, config.test_mode)
    
    # 3. RUNTIME LIFESPAN (mutable resources only)
    cleanup_task: Optional[asyncio.Task] = None
    CLEANUP_INTERVAL_SECONDS = 3600  # hourly
    
    @asynccontextmanager
    async def lifespan(app: FastAPI):
        nonlocal cleanup_task
        
        # STARTUP: Runtime resource setup
        setup_logging(config)
        logger.info("resolved paths: db=%s, admin_token=%s, cert=%s, key=%s, test_mode=%s",
                    db_path, admin_token_path, cert_path, key_path, config.test_mode)
        
        # Database connection
        db_manager.db_path = Path(db_path)
        if not db_manager.connect():
            logger.error("Failed to connect database on startup.")
            raise RuntimeError("DB connect failed")
        
        # Start periodic cleanup task
        async def cleanup_loop():
            loop = asyncio.get_running_loop()
            while True:
                try:
                    deleted_int = await loop.run_in_executor(None, MetricPointsInt.cleanup_old_data, config.metrics_days)
                    deleted_float = await loop.run_in_executor(None, MetricPointsFloat.cleanup_old_data, config.metrics_days)
                    logger.debug("periodic cleanup: removed %s int points, %s float points (%s days)", 
                                deleted_int, deleted_float, config.metrics_days)
                except Exception as e:
                    logger.error("periodic cleanup failed: %s", e)
                await asyncio.sleep(CLEANUP_INTERVAL_SECONDS)
        
        cleanup_task = asyncio.create_task(cleanup_loop())
        logger.info("dcmon server started (host=%s, port=%d)", config.host, config.port)
        
        try:
            yield  # Server runs here
        finally:
            # SHUTDOWN: Cleanup runtime resources
            if cleanup_task:
                cleanup_task.cancel()
                try:
                    await cleanup_task
                except asyncio.CancelledError:
                    pass
            db_manager.close()
            logger.info("dcmon server stopped")

    # 4. CREATE APP AND INCLUDE ROUTES NORMALLY
    app = FastAPI(title="dcmon server", version="0.1.0", lifespan=lifespan)

    # Mount static files BEFORE routes (more specific paths first)
    from fastapi.staticfiles import StaticFiles
    app.mount("/static/ui", StaticFiles(directory="ui"), name="ui")
    app.mount("/static", StaticFiles(directory="static"), name="static")

    # Include all route modules (auth_deps is ready)
    app.include_router(create_auth_routes(auth_deps))
    app.include_router(create_admin_routes(auth_deps))
    app.include_router(create_command_routes(auth_deps))
    app.include_router(create_metrics_routes(auth_deps))
    app.include_router(create_dashboard_routes(auth_deps))

    return app